---
title: "Rapport_projet_DataIFN"
author: "Mathieu PENET, Jean-eudes DELAGE, Roman GARDES, Benoit PERIER "
date: "2024-09-11"
output:
  html_document: default
---

```{r title(Installation des packages), include=FALSE}
# Définir un miroir CRAN global pour l'installation des packages
options(repos = c(CRAN = "https://cloud.r-project.org"))

# Vérifier si les packages sont installés et les installer si nécessaire
required_packages <- c("remotes", "happifn", "happifndata", "FrenchNFIfindeR", "data.table", 
                       "sf", "ggplot2", "dplyr", "tidyr", "tmap", "leaflet", "kableExtra", "mapview")

for (pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}

# Charger les packages
library(remotes)
library(happifn)
library(happifndata)
check_happifndata()  # Vérification des données IFN
library(data.table)
library(sf)
library(ggplot2)
library(dplyr)
library(tidyr)
library(tmap)
library(kableExtra)
library(mapview)
library(leaflet)

```

```{r title(Installation dossier travail)}
# Installation du dossier de travail
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
dir <- getwd()

```

```{r title (Installation extension Github), echo = FALSE, results='hide', message=FALSE, warning=FALSE}
# Installation des extensions Github ----
devtools::install_github("paul-carteron/happifn")


```

```{r title(Récupération des données IFN), echo = FALSE, results='hide', message=FALSE,, warning=FALSE}
get_dataset_names()  # Permet d'obtenir les noms des fichiers fournis par IFN
arbre <- get_ifn("arbre")
placette <- get_ifn("placette")
habitat <- get_ifn("habitat")
ecologie <- get_ifn("ecologie")
flore <- get_ifn("flore")
metadata <-get_ifn_metadata()  # Chargement des metadonnee
```

```{r title(Récupération des métadonnées), warning=FALSE}
# On charge indépendament toutes les listes de metadata
code <- metadata[[1]]
units <- metadata[[2]]
units_value_set <- metadata[[3]]

# On identifie les libelles des essences
code_essence <- units_value_set %>% 
  filter(units == "ESPAR")

# On identifie les libelles de 'VEGET'
code_veget <- units_value_set %>%
  filter(units %in% c("VEGET5", "VEGET56", "VEGET57", "VEGET59")) %>%
  mutate(units = "VEGET") %>%
  distinct(code, .keep_all = TRUE)  # Retirer les doublons

# On identifie les libelles des peuplements
code_habitat <- units_value_set %>% 
  filter(units == "CD_HAB")
```

# Introduction

L'analyse de l'accroissement forestier à partir des données de l'Inventaire Forestier National (IFN) constitue un enjeu majeur pour la gestion durable des forêts françaises, offrant des informations détaillées sur la croissance des arbres en fonction des essences et des catégories de diamètre. L’objectif de cette étude est de développer une méthodologie permettant de calculer ces accroissements moyens et courants en utilisant des placettes IFN dans une zone définie par un buffer spatial. Ce projet s’inscrit dans une démarche exploratoire visant à extraire des métriques pertinentes pour une meilleure compréhension des dynamiques forestières locales.

Les données fournies par l’IFN, bien que riches et précieuses, se caractérisent par une certaine complexité. À partir de ces données brutes, il est essentiel de réaliser les bonnes jointures et intersections spatiales pour obtenir des résultats fiables et pertinents sur l’évolution des forêts à travers le prisme de l’accroissement. La récupération et le traitement de ces données peuvent se faire de deux manières principales : soit en utilisant le package {happifn}, qui facilite l’accès aux données IFN à travers des outils automatisés, soit en accédant directement aux bases de données via le site de l’IFN, ce qui exige une manipulation manuelle des métadonnées et une compréhension fine de la structure des données.

Dans cette étude, une attention particulière est accordée à la différenciation des accroissements par essence et par classe de diamètre, offrant ainsi des informations précises sur la dynamique forestière. Les résultats de cette analyse visent à être utilisés dans un cadre plus large de gestion forestière, et les méthodes développées pourraient potentiellement être intégrées dans le package `happifn` pour une utilisation par la communauté scientifique et les gestionnaires forestiers. Cette démarche s’inscrit dans une volonté d’optimiser l’utilisation des données IFN tout en offrant des outils performants et adaptés aux besoins de l’analyse forestière.

# Materiel et méthodes

## L'accroissement en suface terrière de la zone d'étude

La fonction principale, `get_acc_G()`, permet à l'utilisateur de sélectionner une zone d'étude, d'afficher les placettes présentes dans cette zone, puis de générer deux tableaux : capital_placette et table_recap_final_G.

1.  Tableau `capital_placette` : Ce tableau affiche les essences présentes par placette, ainsi que les informations suivantes : - `Essence` : l'essence d'arbre observée, - `IDP` : le numéro de la placette correspondante, - `capital_essence` : le capital de surface terrière par essence et par placette (en m²/ha), - `acc_essence` : l'accroissement moyen de la surface terrière par essence et par placette (en m²/ha/an), - `taux_acc_G` : le taux d'accroissement de la surface terrière, exprimé en pourcentage du capital sur pied (en m²/ha).

2.  Tableau `table_recap_final_G` : Ce tableau présente un résumé de l'accroissement de la surface terrière pour chaque essence sur l'ensemble de la zone d'étude. Il contient les informations suivantes : - Les essences d'arbres observées, - La moyenne d'accroissement de la surface terrière par essence et par catégorie de bois ("PB" pour petit bois, "BM" pour bois moyen, et "GB" pour gros bois) en m²/ha/an, - La moyenne d'accroissement de la surface terrière par essence (`moy_acc_g_m2_ha`, en m²/ha/an), - Le taux moyen d'accroissement de la surface terrière par essence sur la zone (`moy_taux_acc_G`), - Le nombre total d'arbres mesurés dans la zone (total_arbres_mesures), - L'écart-type du taux d'accroissement, - L'intervalle de confiance maximal et minimal du taux d'accroissement.

Dans la fonction `get_acc_G()`, plusieurs sous-fonctions sont utilisées pour réaliser chaque étape nécessaire à l'extraction et au calcul des données pertinentes liées aux accroissements. Ces étapes permettent de filtrer les données, calculer les accroissements, et générer les tableaux finaux de résultats.

### Aquisition de la zone d'étude

Comme évoqué précédemment,l'objectif de ce projet est de pouvoir informer le gestionnaire sur les potentialités de croissance de ces peuplements et de ces arbres. À titre d'exemple, un gestionnaire privé, faisant l'acquisition récente d'un massif forestier en gestion, a besoin d'information sur la croissance des peuplements. On émet l'hypothèse que le massif étudié ne dispose pas d'inventaire par placette permanente qui permet de définir avec précision un accroissement localisé des essences.

Ainsi, notre objectif a été de construire un ensemble de fonctions R, permettant de fournir des informations précises, avec un indice de fiabilité des données de sorties et des possibilités de filtre concernant les contextes sylvicoles souvent varié à l'échelle d'un territoire.

Dans notre cas concret explicité dans ce rapport nous prendrons à titre d'exemple, le parc naturel régional de chartreuse.

Pour cela, les gestionnaires peut soit dessiner la zone sur une carte, soit importer un fichier `.shp`, souvent un fichier vecteur d'assemblage cadastral.

La fonction `get_import_zone`, permet d'afficher une carte interactive, ou le gestionnaire peut dessiner aisément la forme du massif sur un fond OpenStreet Map. Par la suite, la forme est convertie en sf, pour faciliter son utilisation dans les fonctions suivantes et est conservé dans le système de projection Lambert 93 (EPSG : 2154), au sein de la variable shp_etude. Également, le gestionnaire peut importer une géométrie dessinée préalablement, c'est cette fonctionnalité que nous utiliserons par la suite.

```{r title : Importation de la zone etude, warning=FALSE}
get_import_zone <- function(){
  # Code utilisé pour importer un shape----
  #shp_path <- file.choose()  # Ouvrir les fichiers locaux du PC
  shp_etude <- st_read("./shp_exemple_rapport_projet.shp")  # Importer le shapefile sélectionné ds l'env
  # Convertir l'objet en sf si nécessaire
  # "finished" contient la géométrie dessinée
  
  
  # Code pour dessiner une features avec mapedit----
  # Créer une carte leaflet centrée sur la France
  #france_center <- c(2.2137, 46.2276)  # Longitude, Latitude approximative de la France
  #map <- leaflet() %>%
    #addTiles() %>%
    #setView(lng = france_center[1], lat = france_center[2], zoom = 6)
  
  # Utiliser cette carte avec drawFeatures pour dessiner la zone d'étude
  #drawn_zone <- drawFeatures(map = map)
  
  # Vérifier si quelque chose a été dessiné
  #if (is.null(drawn_zone)) {
    #stop("Aucune zone n'a été dessinée. Veuillez dessiner une zone avant de continuer.")
  #}
  
  # Convertir l'objet dessiné en sf si nécessaire
  #shp_etude <- st_as_sf(drawn_zone)
  
  # Vérifier si la conversion a bien fonctionné
  #if (is.null(shp_etude)) {
    #stop("Erreur lors de la conversion en objet sf.")
  #}
  # Assurez-vous que les coordonnées sont correctement transformées
  # Les données placette IFN étant en lambert 93 (2154)
  shp_etude <- st_transform(shp_etude, 2154)
  
  # Sauvegarder la zone d'étude dans l'environnement
  shp_etude <<- shp_etude

  
  return (shp_etude)  # return les géométrie chargé
}

```

### Buffer sur la zone d'étude

Après l'importation de la zone d'étude, la fonction `get_buffer_zone` permet de lire la géométrie enregistrée précédemment et de la croiser avec la géométrie des placettes de l'Inventaire Forestier National (IFN), déjà disponible sous forme de données spatiales (sf) grâce au package `happifn` (`get_ifn("placette")`).

Si la zone d'étude est de petite taille (\< 100 ha), il est recommandé d'ajouter une distance de buffer autour de la géométrie d'étude. Cette extension de la zone permet d'inclure davantage de placettes de l'IFN, offrant ainsi plus de données sur les essences voisines et leur accroissement.

Cependant, l'utilisation de cette fonction de buffer peut également présenter des contraintes. Elle peut entraîner l'inclusion de données d'accroissement et de cortèges d'essences qui ne sont pas représentatives du contexte sylvicole spécifique rencontré par le gestionnaire. Il est donc conseillé de ne pas superposer les données provenant de plusieurs sylvoécorégions ou, si possible, de plusieurs régions forestières, afin de maintenir une homogénéité dans le contexte sylvicole analysé.

Enfin, une fois l'ensemble des placettes situé dans la zone d'étude récupérée, le code collecte toutes les données relatives aux arbres mesurés sur ces placettes. Ces données sont ensuite conservées dans une table appelée `arbre_zone_etude`.

```{r title : Fonction buffer de la zone etude, warning=FALSE}
# Fonction obtention buffer et placette à l'intérieur ----
get_buffer_zone <- function(buffer = 0){
  
  # Création de la zone tampon autour du shapefile
  zone_tampon <<- st_buffer(shp_etude, dist = buffer)
  
  # Selection des placettes uniquement dans la zone tampon
  placette_tampon <<- st_intersection(placette, zone_tampon)
  
  # Obtenir les limites combinées de toutes les couches pour ajuster le zoom
  all_bounds <<- st_bbox(st_union(st_geometry(shp_etude),
                                 st_geometry(zone_tampon),
                                 st_geometry(placette_tampon)))
  
  # Extraire les IDP des placettes dans la zone tampon
  idp_placette_tampon <<- placette_tampon$IDP
  
  # Filtre les arbres ayant le même IDP que les placettes de la zone
  arbre_zone_etude <<- arbre[arbre$IDP %in% idp_placette_tampon, ]
  
  
  # Convertir l'objet dessiné en sf si nécessaire
  shp_etude <- st_as_sf(shp_etude)
  
  # Vérifier si la conversion a bien fonctionné
  if (is.null(shp_etude)) {
    stop("Erreur lors de la conversion en objet sf.")
  }
  # Assurez-vous que les coordonnées sont correctement transformées
  # Les données placette IFN étant en lambert 93 (2154)
  shp_etude <<- st_transform(shp_etude, 2154)
  
  return(list(idp_placette_tampon,arbre_zone_etude))
  
}
```

```{r, warning=FALSE}
get_read_map <- function(){
  # Passer en mode interactif avec tmap
  tmap_mode("view")
  
  # Choisir le CRS de la zone d'étude
  common_crs <- st_crs(shp_etude)  
  zone_tampon <- st_transform(zone_tampon, common_crs)
  placette_tampon <- st_transform(placette_tampon, common_crs)
  
  
  # Calculer le nombre de placettes et d'arbres dans la zone tampon
  nombre_placettes <- nrow(placette_tampon)  # Nombre de placettes dans la zone tampon
  nombre_arbres <- nrow(arbre_zone_etude)  # Nombre d'arbres dans la zone tampon
  
  titre <- paste("Placettes dans la zone",
                 "\nNombre de placettes :", nombre_placettes,
                 "\nNombre d'arbres :", nombre_arbres)
  
  # Afficher la carte avec tmap et ajuster le zoom sur toutes les couches
  plot_zone <<- tm_shape(shp_etude, bbox = all_bounds) +  # Zone d'étude originale avec ajustement des limites
    tm_fill(col = "lightgreen", alpha = 0.3) +  # Remplissage vert avec transparence
    tm_borders(col = "black") +  # Contour noir
    tm_shape(zone_tampon) +  # Zone tampon
    tm_borders(col = "blue", lty = "dashed") +  # Ligne bleue en pointillé
    tm_shape(placette_tampon) +  # Placettes dans la zone tampon
    tm_symbols(col = "red", size = 0.005) +  # Placettes en rouge
    tm_layout(main.title = titre,
              main.title.size = 1,
              frame = TRUE)  # Ajouter un titre, sans cadre
  return(plot_zone)

}
```

### Arrangement des données brut extraite par le buffer

La fonction `get_arrange_data()` est utilisée pour transformer et nettoyer les données d'une base qui contient des informations sur des arbres mesurés à différentes périodes. Elle réalise plusieurs opérations essentielles pour organiser les données, notamment la création d'identifiants uniques pour chaque arbre, la gestion des valeurs manquantes et la consolidation des mesures prises au fil du temps. Voici les principales étapes de traitement effectuées :

Création d'un identifiant unique : Un identifiant unique, nommé `num_unique`, est généré pour chaque arbre en concaténant l'ID de la placette (`IDP`) et le numéro de l'arbre (`A`). Cette opération permet d'assurer une identification claire et sans ambiguïté de chaque arbre dans la base de données.

Consolidation des années de campagne et des circonférences mesurées : Pour chaque arbre, deux nouvelles colonnes sont créées :

-   `annee_mesure` regroupe les années uniques de mesure (`CAMPAGNE`), sous forme de chaîne de caractères, séparées par des virgules.

-   `circ_mesure` compile les valeurs de circonférence (`C13`), en excluant les valeurs manquantes, pour chaque arbre. Cela permet de suivre l'évolution des mesures dans le temps. Gestion des valeurs manquantes dans l'espèce (`ESPAR`) : Les valeurs vides ou incorrectes dans la colonne représentant l'espèce (ESPAR) sont systématiquement remplacées par des valeurs manquantes (`NA`), assurant ainsi la cohérence des données.

Remplissage des valeurs manquantes : La colonne `ESPAR` est ensuite complétée là où c'est possible en utilisant les informations disponibles pour le même arbre. Ce processus remplit les valeurs manquantes par les données présentes au-dessus et en dessous dans le tableau, garantissant ainsi que les espèces soient renseignées pour chaque arbre, lorsque cela est possible.

En conclusion, cette fonction permet d'obtenir un ensemble de données plus structuré, propre et cohérent, facilitant ainsi les analyses ultérieures.

```{r title(Fonction d arrangement des données), warning=FALSE}
get_arrange_data <- function(){
  
  # Fabrication d'un numéro unique pour chaque arbre
  arbre_zone_etude$num_unique <- paste(arbre_zone_etude$IDP,
                                       arbre_zone_etude$A,
                                       sep = ".")
  
  # Créer une nouvelle colonne qui stocke toutes les années de campagne pour chaque IDP
  arbre_zone_etude <- arbre_zone_etude %>%
    group_by(num_unique) %>%
    mutate(
      # Créer une chaîne de caractères avec les années uniques
      annee_mesure = paste(unique(CAMPAGNE), collapse = ", "),
      
      # Créer une liste avec les mesures de circonférences
      circ_mesure = paste(na.omit(C13), collapse = ", ")  
    ) %>%
    ungroup()
  
  # Les sections vides dans ESPAR sont remplacé par NA
  arbre_zone_etude$ESPAR[arbre_zone_etude$ESPAR == "" | arbre_zone_etude$ESPAR == " "] <- NA
  
  # Remplir les valeurs manquantes de code ESPAR pour chaque arbre
  arbre_zone_etude_cor <<- arbre_zone_etude %>%
    group_by(num_unique) %>%
    
    # Remplir les valeurs manquantes par les valeurs non manquantes
    fill(ESPAR, .direction = "downup") %>%  
    ungroup()  # Désactiver le regroupement
  
  return (arbre_zone_etude_cor)
}
```

### Obtention des espèces par placette

La fonction `get_species` ajoute une colonne appelée `Essence` au tableau `arbre_zone_etude_cor`, qui contient le libellé correspondant à l'essence de chaque arbre en fonction des codes `ESPAR`. Elle initialise la colonne avec des valeurs manquantes (`NA`), puis parcourt chaque ligne du tableau pour vérifier si un code `ESPAR` est disponible. Si ce n'est pas le cas, elle cherche une correspondance dans la table `code_veget` à partir du code `VEGET`. Si un code `ESPAR` est présent, elle le convertit en libellé d'essence via la table `code_essence`. Si aucune correspondance n'est trouvée, l'essence est marquée comme `Indéterminée`. Cette opération, bien qu'elle ne soit pas essentiel dans la fabrication des tables d'accroissements permet de visualiser de façon intermédiaire dans le code, la fréquence de certaine essence et de rendre plus accessible la lecture de la table de données.

```{r title(Fonction de récupération des libelles d essence), warning=FALSE}
get_species <- function(){
  # Ajout de la colonne Essence
  arbre_zone_etude$Essence <- NA
  
  
  # Boucle de remplissage des libellés pour chaque code Essence
  for (i in 1:nrow(arbre_zone_etude_cor)) {
    # Récupérer le code ESPAR pour l'arbre à la ligne `i`
    code_espar <- arbre_zone_etude_cor$ESPAR[i]
    code_veget5 <- arbre_zone_etude_cor$VEGET[i]
    
    # Si le code ESPAR est NA, remplacer par le libelle de code_veget
    if (is.na(code_espar)) {
      # Ajouter l'essence correspondante depuis code_veget
      veget_correspondante <- code_veget$libelle[code_veget$code == code_veget5]
      arbre_zone_etude_cor$Essence[i] <- veget_correspondante
    } else {
      # Trouver l'essence correspondante dans la table `metadonnees`
      essence_correspondante <- code_essence$libelle[code_essence$code == code_espar]
      
      # Vérifier si une essence a été trouvée
      if (length(essence_correspondante) > 0) {
        # Ajouter l'essence à la colonne "Essence" de `arbre_zone_etude_cor`
        arbre_zone_etude_cor$Essence[i] <- essence_correspondante
      } else {
        # Si aucun code ESPAR correspondant n'est trouvé, laisser la valeur par défaut (NA)
        arbre_zone_etude_cor$Essence[i] <- "Indetermine"
      }
    }
  }
  
  # Réorganiser les colonnes pour mettre "Essence" en première position
  arbre_zone_etude_cor <- arbre_zone_etude_cor %>%
    select(Essence, everything())  # Déplace la colonne Essence en première position
  
  arbre_zone_etude_cor <<- arbre_zone_etude_cor
  return(arbre_zone_etude_cor)
}

```

### Les variables dendrométriques utilisées

La fonction `get_data_dendro` est conçue pour calculer des variables dendrométriques clés pour chaque arbre dans une zone d'étude. Elle commence par sélectionner des colonnes importantes dans la base de données, telles que l'identifiant unique, l'essence, les années de campagne, et les circonférences. Ensuite, elle réorganise les données pour que chaque campagne soit représentée par une colonne distincte, en utilisant les valeurs de circonférence mesurées. Elle regroupe les données par arbre et extrait les premières valeurs non manquantes pour résumer les informations.

La fonction crée des vecteurs d'années et de circonférences pour chaque arbre, afin d'extraire les années maximales et minimales ainsi que les circonférences maximales et minimales. Elle classifie ensuite les arbres en différentes catégories de diamètre en fonction de la circonférence maximale, en créant une variable "cat_diam" qui détermine si l'arbre appartient à la classe Petit Bois, Bois Moyen ou Gros Bois.

Elle ajuste ensuite la pondération w en fonction de la catégorie de diamètre et de la valeur de `W` (donnée de base du poids statistique de l'IFN). Si `W` est manquant, elle attribue une valeur par défaut basée sur la catégorie de diamètre de l'arbre. La fonction calcule ensuite le diamètre de l'arbre et sa classe de diamètre, avant de calculer l'accroissement en surface terrière (G) par hectare et par année en utilisant les circonférences minimale et maximale. Finalement, elle renvoie la base de données mise à jour.

```{r title(Fonction de calcul des données dendrométrique de base), warning=FALSE}
get_data_dendro <- function(){
  
  # On sélectionne uniquement quelques colonnes utile
  arbre_zone_etude_cor <- arbre_zone_etude_cor %>%
    select(IDP,CAMPAGNE, num_unique, Essence, C13,C0, VEGET, VEGET5, HTOT, HDEC, V, W, IR5, IR1, annee_mesure, circ_mesure) %>%
    
    pivot_wider(names_from = CAMPAGNE,   # Créer des colonnes pour chaque année
                values_from = C13) %>%  # Les valeurs à placer dans ces colonnes sont les circonférences mesurées
    
    group_by(num_unique) %>%
    summarise(across(everything(), ~ first(na.omit(.)), .names = "{col}"), .groups = "drop")
  
  # On cherche la circonférence max dans la liste
  arbre_zone_etude_cor <<- arbre_zone_etude_cor %>%
    group_by(num_unique) %>%
    # Calculer l'accroissement annuel
    mutate(
      # Séparer la chaîne de caractères en vecteur d'années pour chaque ligne
      annee_vector = list(as.numeric(strsplit(annee_mesure, ",\\s*")[[1]])),
      circ_vector = list(as.numeric(strsplit(circ_mesure, ",\\s*")[[1]])),
      
      # Extraire l'année maximale et minimale
      annee_max = max(annee_vector[[1]], na.rm = TRUE),  # L'année de la circonférence max
      annee_min = min(annee_vector[[1]], na.rm = TRUE),  # L'année de la circonférence min
      
      # Extraire la circonférence maximale et minimale
      circonference_max = max(circ_vector[[1]], na.rm = TRUE),  # La circonférence max
      circonference_min = min(circ_vector[[1]], na.rm = TRUE))%>%  # La circonférence min
    
    mutate(cat_diam = case_when(
      circonference_max >= 0.235 & circonference_max < 0.705 ~ "PB",   # Petite Bois (PB)
      circonference_max >= 0.705 & circonference_max < 1.175 ~ "BM",  # Bois Moyen (BM)
      circonference_max >= 1.175 ~ "GB",  # Gros Bois (GB))
      TRUE ~ NA_character_ ))%>%
    
    mutate(W = as.numeric(W),  # Transformer la variable W en numeric
           w = case_when(
             !is.na(W) ~ W,  # Si W n'est pas NA, w prend la valeur de W
             is.na(W) & cat_diam == "PB" ~ 88.4,  # Si W est NA et cat_diam est "PB", w prend 88.4
             is.na(W) & cat_diam == "BM" ~ 39.3,  # Si W est NA et cat_diam est "BM", w prend 39.3
             is.na(W) & cat_diam == "GB" ~ 14.1,  # Si W est NA et cat_diam est "GB", w prend 14.1
             TRUE ~ NA_real_  # Si aucune condition n'est remplie, w prend NA
           )) %>%
    
    mutate(
      # On calcul le diamètre de l'arbre
      diam = round((circonference_max / pi)/0.01,1),
      # On calcul sa classe de diam
      clas_diam = round(diam / 5) * 5
    ) %>%
    
    mutate(
      # Calcul accroissement en G/ha/an
      g_min = ((circonference_min^2) / (4 * pi)),
      g_max = ((circonference_max^2) / (4 * pi)),
      g_max_ha = g_max * w
    )
  return(arbre_zone_etude_cor)
  
  
}

```

### Récupération de l'état de végétation des arbres

La fonction `get_veget()` est conçue pour normaliser et enrichir les informations sur les états de végétation des arbres dans une base de données en consolidant différentes sources de données et en ajoutant des libellés descriptifs. Voici un aperçu des étapes de traitement effectuées par cette fonction :

Création d'une colonne consolidée pour l'état de végétation : La fonction commence par créer une nouvelle colonne, `VEGET_cor`, dans le tableau `arbre_zone_etude_cor`. Cette colonne est remplie en utilisant une logique de priorité :

Si la colonne `VEGET5` n'est pas manquante (`NA`), sa valeur est utilisée pour `VEGET_cor`. Si `VEGET5` est manquante mais `VEGET` n'est pas manquante, la valeur de `VEGET` est utilisée. Si les deux colonnes (`VEGET` et `VEGET5`) sont manquantes, la valeur par défaut "`indetermine`" est attribuée à `VEGET_cor`. Enrichissement des données avec des libellés descriptifs : La fonction effectue ensuite une jointure avec une table externe, `code_veget`, qui contient les codes de végétation et leurs descriptions. Cette jointure est réalisée en utilisant `VEGET_cor` comme clé pour faire correspondre les codes avec les libellés descriptifs dans `code_veget`.

`left_join()` : Cette opération fusionne `arbre_zone_etude_cor` avec `code_veget` en se basant sur les codes de végétation. `mutate()` : Une fois la jointure effectuée, la colonne `veget_etat` est ajoutée, contenant les libellés descriptifs obtenus depuis `code_veget`. Nettoyage des données : Après la jointure, les colonnes `definition`, `libelle`, et `units` de la table `code_veget` sont supprimées, ne laissant que les colonnes pertinentes pour l'analyse.

Retour des résultats : La fonction renvoie la table mise à jour `arbre_zone_etude_cor`, qui contient désormais les états de végétation enrichis avec des libellés descriptifs clairs.

```{r title : Definition des etats de vegetation des arbres, warning=FALSE}
get_veget <- function(){
  
  arbre_zone_etude_cor <<- arbre_zone_etude_cor %>%
    mutate(VEGET_cor = case_when(
      !is.na(VEGET5) ~ VEGET5,      # Si VEGET5 n'est pas NA, prendre VEGET5
      !is.na(VEGET) ~ VEGET,        # Si VEGET5 est NA mais VEGET n'est pas NA, prendre VEGET
      is.na(VEGET) & is.na(VEGET5) ~ "indetermine"  # Si les deux sont NA, inscrire "indetermine"
    ))
  # Ensuite, faisons une jointure avec la table code_veget pour obtenir les libellés
  arbre_zone_etude_cor <<- arbre_zone_etude_cor %>%
    left_join(code_veget, by = c("VEGET_cor" = "code")) %>%  # Assurez-vous que 'code' est la colonne correspondante dans code_veget
    mutate(veget_etat = libelle) %>%
    select(-definition, -libelle, -units)
  
  #select(veget_etat,everything())
  
  #arbre_zone_etude_cor <<- arbre_zone_etude_cor
  
  return(arbre_zone_etude_cor)
  
}
```

### Calcul de l'accroissement en surface terrière G

La fonction `get_calc_G` calcule l'accroissement annuel de la surface terrière (G) pour chaque arbre vivant dans la zone d'étude, à condition qu'il y ait une différence mesurable de circonférence entre deux périodes d'observation. Le calcul prend en compte la période d'observation pour déterminer le nombre d'années séparant les 2 mesures et un facteur de pondération (`w` = poids statistique de l'arbre) pour ajuster la surface terrière par hectare.

```{r title : calcul brut de accroissement en G, warning=FALSE}
# Fonction calcul accroissement en G/ha/an ----
get_calc_G <- function(){
  arbre_zone_etude_cor <<- arbre_zone_etude_cor %>%
    group_by(num_unique) %>%
    # Calculer l'accroissement annuel en G
    mutate(
      acc_g_ha = if_else(
        circonference_max != circonference_min & veget_etat=="Arbre vivant sur pied",
        ((g_max - g_min) * w / (annee_max - annee_min)),
        NA_real_  # Sinon NA
      ))
  return(arbre_zone_etude_cor)
  
}
```

```{r, echo = FALSE, results='hide', message=FALSE, warning=FALSE}
# Fonction calcul accroissement en V/m3/an----
get_calc_V_ha <- function() {
  arbre_zone_etude_cor <<- arbre_zone_etude_cor %>%
    group_by(num_unique) %>%
    # Calculer l'accroissement annuel en V
    mutate(
      # Calculer l'accroissement volumique par hectare
      acc_V_ha = if_else(!is.na(accroissement_volumique) & !is.na(w), 
                         accroissement_volumique * w, 
                         NA_real_)  # Si l'un des deux est NA, retourner NA
    )
  
  # Vérifier si acc_V_ha est bien calculé
  print(head(arbre_zone_etude_cor$acc_V_ha))  # Afficher les premières valeurs calculées
  
  return(arbre_zone_etude_cor)
}
```

Une fonction similaire est disponible pour calculer l'accroissement en volume `get_calc_V_ha`

### Calcul du taux d'accroissement :

La fonction `get_taux_acc_g()` est conçue pour calculer les taux d'accroissement en surface terrière (G) et en volume (V) pour les arbres d'une étude, en regroupant les données par essence et par placette. Elle exécute plusieurs étapes de calcul et de nettoyage des données pour fournir un résumé des indicateurs de capitales et des accroissements.

Les principales étapes de traitement de la fonction sont les suivantes :

Calcul du nombre d'arbres mesurés par essence et par placette : La fonction commence par créer un tableau résumant le nombre d'arbres mesurés dans chaque placette (IDP) pour chaque essence (Essence). Le nombre d'arbres est déterminé en comptant les valeurs valides dans la colonne `acc_g_ha`, qui correspond à l'accroissement en surface terrière par hectare. Cette étape permet de connaître le nombre d'arbres utilisés dans les calculs d'accroissement.

Calcul des statistiques de capital et d'accroissement : Pour chaque essence et chaque placette, la fonction calcule :

Capital en surface terrière (`capital_essence`) : Somme de la surface terrière maximale par hectare (`g_max_ha`) des arbres dans la placette, après avoir ignoré les valeurs manquantes. Accroissement en surface terrière (`acc_essence`) : Somme des accroissements valides de surface terrière par hectare (`acc_g_ha`), ce qui permet de quantifier l'évolution des arbres au fil du temps. Taux d'accroissement (`taux_acc_G`) : Calculé en pourcentage, il s'agit du rapport entre l'accroissement et le capital, en veillant à éviter les divisions par zéro. Jointure avec les statistiques d'arbres mesurés : Les statistiques calculées précédemment sont fusionnées avec les données de comptage des arbres, pour chaque essence et placette, à l'aide d'une jointure basée sur les colonnes `Essence` et `IDP`.

Nettoyage des données : Plusieurs vérifications et corrections sont appliquées :

Les valeurs infinies ou quasi infinies dans les colonnes calculées (capital, accroissement, taux) sont remplacées par des valeurs manquantes (`NA`). Un filtrage est appliqué pour éliminer les placettes dont les accroissements sont proches de zéro, garantissant ainsi la pertinence des résultats. Affichage et retour des résultats : Après ces étapes, le tableau final (`capital_placette`) est renvoyé et affiché, contenant les taux d'accroissement en surface terrière et les autres statistiques pertinentes pour chaque combinaison d'essence et de placette.

Cette fonction permet ainsi de résumer de manière synthétique l'évolution des surfaces terrières dans les placettes étudiées, en prenant en compte les différentes essences présentes dans la zone d'étude.

```{r title(Fonction calcul taux accroissement en surface terrière), warning=FALSE}
# Fonction de calcul du taux d'accroissement pour le volume et la G
get_taux_acc_g <- function(){
  # Calculer le nombre d'arbres mesurés pour chaque essence et chaque placette (IDP)
  nombre_arbres_par_essence_placette <- arbre_zone_etude_cor %>%
    group_by(Essence, IDP) %>%
    summarise(
      nombre_arbres_mesures = sum(!is.na(acc_g_ha) & is.finite(acc_g_ha) & acc_g_ha != 0),  # Compte des arbres mesurés
      .groups = 'drop'
    )
  
  # Calculer les statistiques de capital et d'accroissement
  capital_placette <<- arbre_zone_etude_cor %>%

    group_by(Essence, IDP) %>%
    summarise(
      capital_essence = sum(g_max_ha, na.rm = TRUE),
      acc_essence = sum(
        if_else(!is.na(acc_g_ha), acc_g_ha, NA_real_), 
        na.rm = TRUE ), # Ignorer les NA générés lorsque les circonférences sont égales
      
      taux_acc_G = if_else(capital_essence != 0, acc_essence * 100 / capital_essence, NA_real_),# Éviter division par zéro
      .groups = 'drop'  # Retirer les groupes après le résumé
    ) %>%
    
    left_join(nombre_arbres_par_essence_placette, by = c("Essence", "IDP")) %>%
    
    # Nettoyer les valeurs infinies et quasi infinies
    mutate(
      capital_essence = if_else(is.finite(capital_essence), capital_essence, NA_real_),
      acc_essence = if_else(is.finite(acc_essence), acc_essence, NA_real_),
      taux_acc_G = if_else(is.finite(taux_acc_G), taux_acc_G, NA_real_)
    ) %>%
    
    # Filtrer les lignes avec des valeurs proches de zéro
    filter(
      #abs(capital_essence) > 1e-7,  # Retirer les lignes où capital_essence est presque zéro
      abs(acc_essence) > 1e-7,      # Retirer les lignes où acc_essence est presque zéro
      #abs(taux_acc_G) > 1e-7        # Retirer les lignes où taux_acc_G est presque zéro
    )
  
  View(capital_placette)
  
  return(capital_placette)
}
```

Une fonction similaire est disponible pour calculer le taux d'accroissement du volume

```{r title(Fonction calcul taux accroissement en Volume), echo = FALSE, results='hide', message=FALSE, warning=FALSE}
get_taux_acc_V <- function(){
  # Calculer le nombre d'arbres mesurés pour chaque essence et chaque placette (IDP)
  nombre_arbres_par_essence_placette <- arbre_zone_etude_cor %>%
    group_by(Essence, IDP) %>%
    summarise(
      nombre_arbres_mesures = sum(!is.na(acc_V_ha) & is.finite(acc_V_ha) & acc_V_ha != 0),  # Compte des arbres mesurés
      .groups = 'drop'
    )
  
  # Calculer les statistiques de capital et d'accroissement
  volume_placette <<- arbre_zone_etude_cor %>%
    
    group_by(Essence, IDP) %>%
    summarise(
      volume_essence = sum(V_max_ha, na.rm = TRUE),
      acc_essence = sum(
        if_else(!is.na(acc_V_ha), acc_V_ha, NA_real_), 
        na.rm = TRUE ), # Ignorer les NA générés lorsque les circonférences sont égales
      
      taux_acc_V = if_else(volume_essence != 0, acc_essence * 100 / volume_essence, NA_real_),# Éviter division par zéro
      .groups = 'drop'  # Retirer les groupes après le résumé
    ) %>%
    
    left_join(nombre_arbres_par_essence_placette, by = c("Essence", "IDP")) %>%
    
    # Nettoyer les valeurs infinies et quasi infinies
    mutate(
      volume_essence = if_else(is.finite(volume_essence), volume_essence, NA_real_),
      acc_essence = if_else(is.finite(acc_essence), acc_essence, NA_real_),
      taux_acc_V = if_else(is.finite(taux_acc_V), taux_acc_V, NA_real_)
    ) %>%
    
    # Filtrer les lignes avec des valeurs proches de zéro
    filter(
      #abs(capital_essence) > 1e-7,  # Retirer les lignes où capital_essence est presque zéro
      abs(acc_essence) > 1e-7,      # Retirer les lignes où acc_essence est presque zéro
      #abs(taux_acc_G) > 1e-7        # Retirer les lignes où taux_acc_G est presque zéro
    )
  
  View(volume_placette)
  
  return(volume_placette)
}

```

### Lecture et affichage des données d'accroissement :

La fonction `get_read_acc_G()` permet de calculer et de synthétiser les accroissements en surface terrière par hectare (`acc_g_ha`) pour chaque essence d'arbres, selon différentes catégories de diamètre et par placette forestière. Elle produit un tableau récapitulatif global des accroissements avec et sans prise en compte des catégories de diamètre, offrant ainsi une vue d'ensemble des taux de croissance par essence.

Étapes de la fonction : Calcul des moyennes d'accroissement par essence, catégorie de diamètre, et placette : La première étape consiste à filtrer les valeurs infinies dans la base de données `arbre_zone_etude_cor`, puis à regrouper les données par placette (IDP), essence, et catégorie de diamètre (`cat_diam`).

La fonction calcule la somme des accroissements pour chaque combinaison de ces trois éléments, créant ainsi un tableau intermédiaire (`table_recap_placette`), où chaque ligne représente l'accroissement total par essence, placette, et catégorie de diamètre.

Calcul de la moyenne d'accroissement sur l'ensemble des placettes pour chaque essence et catégorie de diamètre : Ensuite, la fonction regroupe les données par essence et catégorie de diamètre, puis calcule la moyenne des accroissements sur toutes les placettes (moyenne pondérée sur toutes les placettes mesurées). Les valeurs sont arrondies à trois décimales pour plus de précision. Cette moyenne est ensuite structurée sous forme de tableau (`table_recap_global`), avec les essences en lignes et les catégories de diamètre en colonnes.

Calcul de la moyenne globale par essence, sans distinction de catégorie de diamètre :

Dans cette étape, la fonction calcule la moyenne d'accroissement pour chaque essence, sans prise en compte de la catégorie de diamètre. Cela permet de fournir une vue globale de l'accroissement, toutes catégories confondues. Le résultat est stocké dans `table_recap_global_sans_diam` :

En plus de l'accroissement moyen, la fonction calcule des statistiques supplémentaires, notamment le taux d'accroissement global (`moy_taux_acc_G`), l'écart-type, ainsi que les intervalles de confiance (`IC inférieur et supérieur`) pour chaque essence, basés sur la distribution des taux d'accroissement.

Fusion des résultats avec ou sans catégorie de diamètre :

Pour fournir une vue d'ensemble complète, la fonction fusionne les résultats des deux étapes précédentes (avec et sans catégorie de diamètre) en un tableau final, `table_recap_final_G`, regroupant toutes les informations sur les accroissements par essence, à la fois détaillées par catégorie de diamètre et globalement.

Affichage des résultats :

Enfin, le tableau final des résultats `(table_recap_final_G`) est affiché dans une vue interactive pour permettre un examen facile des accroissements et des taux de croissance des essences étudiées.

Résultats attendus : La fonction `get_read_acc_G()` fournit un récapitulatif complet des taux d'accroissement des essences dans une zone d'étude, avec des moyennes calculées par catégorie de diamètre ainsi que des moyennes globales pour chaque essence. Cela permet une évaluation précise de la croissance forestière selon différents critères et facilite la prise de décision concernant la gestion forestière.

```{r title(Fonction lecture et affichage des données d accroissement), warning=FALSE}
# Fonction de lecture (affichage tableau) des valeurs d'accroissements ----
get_read_acc_G <- function(){
  
  # Calculer les moyennes d'accroissement par essence, catégorie de diamètre et placette
  table_recap_placette <- arbre_zone_etude_cor %>%
    filter(is.finite(acc_g_ha)) %>%  # Exclure les valeurs infinies et petites
    group_by(IDP, Essence, cat_diam) %>%  # Groupement par Placette, Essence et catégorie de diamètre
    summarise(
      moyenne_accroissement = sum(acc_g_ha, na.rm = TRUE),  # Moyenne d'accroissement pour chaque placette
      .groups = 'drop'
    )
  
  # Calculer la moyenne sur toutes les placettes par essence et catégorie de diamètre
  table_recap_global <- table_recap_placette %>%
    group_by(Essence, cat_diam) %>%  # Groupement par Essence et catégorie de diamètre seulement
    summarise(
      moyenne_accroissement_placettes = mean(moyenne_accroissement, na.rm = TRUE),  # Moyenne globale sur toutes les placettes
      .groups = 'drop'
    ) %>%
    mutate(moyenne_accroissement_placettes = round(moyenne_accroissement_placettes, 3)) %>%  # Arrondir à 0.001 près
    pivot_wider(
      names_from = cat_diam,  # Colonnes pour chaque catégorie de diamètre
      values_from = moyenne_accroissement_placettes,
      values_fill = list(moyenne_accroissement_placettes = NA)  # Remplir les valeurs manquantes avec NA
    ) %>%
    arrange(Essence)  # Trier par essence
  
  # Calculer la moyenne globale par essence sans distinction de catégorie de diamètre
  table_recap_global_sans_diam <<- arbre_zone_etude_cor %>%
    filter(is.finite(acc_g_ha)) %>%
    group_by(IDP, Essence) %>%  # Groupement par Placette et Essence uniquement
    summarise(
      moyenne_accroissement_sans_diam = sum(acc_g_ha, na.rm = TRUE),  # Moyenne d'accroissement par placette sans cat_diam
      nombre_arbres_mesures = sum(!is.na(acc_g_ha) & acc_g_ha != 0 & is.finite(acc_g_ha)),
      .groups = 'drop'
    ) %>%
    group_by(Essence) %>%  # Groupement par essence pour faire la moyenne globale de toutes les placettes
    summarise(
      moy_acc_g_m2_ha = mean(moyenne_accroissement_sans_diam, na.rm = TRUE),  # Moyenne globale sur toutes les placettes
      moy_taux_acc_G = mean(capital_placette$taux_acc_G[capital_placette$Essence == Essence], na.rm = TRUE),
      ecart_type = sd(capital_placette$taux_acc_G[capital_placette$Essence == Essence], na.rm = TRUE),
      total_arbres_mesures = sum(nombre_arbres_mesures, na.rm = TRUE),
      IC_inf = moy_taux_acc_G - 1.96 * (ecart_type / sqrt(total_arbres_mesures)),
      IC_sup = moy_taux_acc_G + 1.96 * (ecart_type / sqrt(total_arbres_mesures)),
      
      .groups = 'drop'
    ) %>%
    mutate(moy_acc_g_m2_ha = round(moy_acc_g_m2_ha, 3),
           moy_taux_acc_G = round(moy_taux_acc_G,1))  # Arrondir à 0.001 près
  
  # Fusionner les résultats avec ou sans catégorie de diamètre
  table_recap_final_G <<- table_recap_global %>%
    left_join(table_recap_global_sans_diam, by = "Essence")  # Ajouter la moyenne sans catégorie de diamètre
  
  View(table_recap_final_G)
  
  return(table_recap_final_G)
  
}
```

Une fonction similaire exécute les mêmes opération pour l'ensemble des données récoltés pour les volumes.

```{r title(Fonction lecture et affichage des volumes), echo = FALSE, results='hide', message=FALSE, warning=FALSE}
get_read_acc_V <- function(){
  
  # Calculer les moyennes d'accroissement par essence, catégorie de diamètre et placette
  table_recap_placette <- arbre_zone_etude_cor %>%
    filter(is.finite(acc_V_ha)) %>%  # Exclure les valeurs infinies et petites
    group_by(IDP, Essence, cat_diam) %>%  # Groupement par Placette, Essence et catégorie de diamètre
    summarise(
      moyenne_accroissement = sum(acc_V_ha, na.rm = TRUE),  # Moyenne d'accroissement pour chaque placette
      .groups = 'drop'
    )
  
  # Calculer la moyenne sur toutes les placettes par essence et catégorie de diamètre
  table_recap_global <- table_recap_placette %>%
    group_by(Essence, cat_diam) %>%  # Groupement par Essence et catégorie de diamètre seulement
    summarise(
      moyenne_accroissement_placettes = mean(moyenne_accroissement, na.rm = TRUE),  # Moyenne globale sur toutes les placettes
      .groups = 'drop'
    ) %>%
    mutate(moyenne_accroissement_placettes = round(moyenne_accroissement_placettes, 3)) %>%  # Arrondir à 0.001 près
    pivot_wider(
      names_from = cat_diam,  # Colonnes pour chaque catégorie de diamètre
      values_from = moyenne_accroissement_placettes,
      values_fill = list(moyenne_accroissement_placettes = NA)  # Remplir les valeurs manquantes avec NA
    ) %>%
    arrange(Essence)  # Trier par essence
  
  # Calculer la moyenne globale par essence sans distinction de catégorie de diamètre
  table_recap_global_sans_diam <- arbre_zone_etude_cor %>%
    filter(is.finite(acc_V_ha)) %>%
    group_by(IDP, Essence) %>%  # Groupement par Placette et Essence uniquement
    summarise(
      moyenne_accroissement_sans_diam = sum(acc_V_ha, na.rm = TRUE),  # Moyenne d'accroissement par placette sans cat_diam
      nombre_arbres_mesures = sum(!is.na(acc_V_ha) & acc_V_ha != 0 & is.finite(acc_V_ha)),
      
      .groups = 'drop'
    ) %>%
    group_by(Essence) %>%  # Groupement par essence pour faire la moyenne globale de toutes les placettes
    summarise(
      moy_acc_V_m3_ha = mean(moyenne_accroissement_sans_diam, na.rm = TRUE),  # Moyenne globale sur toutes les placettes
      moy_taux_acc_V = mean(volume_placette$taux_acc_V[volume_placette$Essence == Essence], na.rm = TRUE),
      ecart_type = sd(volume_placette$taux_acc_V[volume_placette$Essence == Essence], na.rm = TRUE),
      total_arbres_mesures = sum(nombre_arbres_mesures, na.rm = TRUE),
      IC_inf = moy_taux_acc_V - 1.96 * (ecart_type / sqrt(total_arbres_mesures)),
      IC_sup = moy_taux_acc_V + 1.96 * (ecart_type / sqrt(total_arbres_mesures)),
      .groups = 'drop'
    ) %>%
    mutate(
      moy_acc_V_m3_ha = round(moy_acc_V_m3_ha, 3),
      moy_taux_acc_V = round( moy_taux_acc_V, 1))  # Arrondir à 0.001 près
  
  # Fusionner les résultats avec ou sans catégorie de diamètre
  table_recap_final_V <<- table_recap_global %>%
    left_join(table_recap_global_sans_diam, by = "Essence")  # Ajouter la moyenne sans catégorie de diamètre
  
  View(table_recap_final_V)
  
  return(table_recap_final_V)
  
}
```

L'ensemble des fonctions rencontrées précédemment permet de faire exécuter la fonction `get_acc_G()`, qui compile tous les éléments.

Dans la suite de ce rapport nous nous interesseront au résultats d'acquisition d'une des fonctions d'accroissement : `get_acc_G()` La zone d'étude étant le Parc naturel régional de chartreuse :

```{r, warning=FALSE}
# Fonction intégral calcul de l'accroissement en G/ha/an sur les placettes
get_acc_G <- function(buffer = 0){
  get_import_zone()
  get_buffer_zone(buffer)
  get_read_map()
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  get_calc_G()
  get_taux_acc_g()
  get_read_acc_G()
  get_stat_essence()
  View(plot)
  
  return(plot_zone)
}

```

Première étape : Chargement de la géométrie correspondant au Parc naturel régional de Chartreuse

```{r, warning=FALSE}
# Importation de la géométrie du Parc naturel régional de Chartreuse
get_import_zone()
```

Récupération des placettes et des données des arbres mesurées dans la zone d'étude

```{r warning=FALSE, include=FALSE}
get_buffer_zone()
```

On peut visualiser rapidement la carte de la zone et des placettes présente dans cette dernière:

```{r, warning=FALSE}
get_read_map()
```

Par la suite, les données sont arrangées pour un meilleur traitement

```{r, warning=FALSE}
get_arrange_data()
```

On récupère les libellés des essences pour chaque arbre dans la zone d'étude

```{r, warning=FALSE}
get_species()
```

Par la suite, la fonction calcul les variables dendrométriques fondamental pour les calculs d'accroissement

```{r, warning=FALSE}
get_data_dendro()
```

On récupère ensuite les états de végétation des arbres mesurés sur la zone

```{r, warning=FALSE}
get_veget()
```

Calcul de l'accroissement en surface terrière :

```{r, warning=FALSE}
get_calc_G()
```

Calcul des taux d'accroissement en surface terrière par essence et par placette.

`Capital_essence` : Capital de l'essence sur la placette de mesure (m²/ha)

`acc_essence` : Accroissement de l'essence sur la placette de mesure (m²/ha/an)

`taux_acc_G` : Taux d'accroissement du capital de l'essence sur la placette de mesure en % `nombre_arbre_mesures` : Nombre d'arbres de l'essence mesures sur la placette

```{r, warning=FALSE}
get_taux_acc_g()
```

Affichage et lecture des données d'accroissement en surface terrière sur la zone d'étude :

```{r, warning=FALSE}
get_read_acc_G()
```

Ainsi la fonction, permet de visualiser les données d'accroissement en surface terrière sur le Parc naturel régional de Chartreuse. On constate que suivant le nombre d'arbres mesurés sur cette zone, certaines essences présentent des taux d'accroissement dont la fiabilité n'est pas suffisante. D'où l'intérêt d'inclure les intervalles de confiance, qui permettent à un gestionnaire d'offrir des informations et les détails de leur calcul. Ainsi il peut prendre en compte les incertitudes et le manque de données pour ne pas surinterpréter les variables d'accroissements en sortie.

## Calcul de l'accroissement en volume (V)

L'accroissement en volume des peuplements est calculé à l'aide d'un ensemble de fonctions, décrites ci-dessous.

`selectionner_essence` : Cette fonction permet de filtrer les données pour une essence d'arbre spécifique. Elle affiche toutes les essences disponibles dans la base de données, puis demande à l'utilisateur de sélectionner l'essence qu'il souhaite étudier. Les données pour cette essence sont ensuite extraites.

```{r, warning=FALSE}

# Fonction pour afficher les essences disponibles et sélectionner une essence
selectionner_essence <- function(data) {
  #essences_disponibles <- unique(data$Essence)
  #print("Essences disponibles :")
  #print(essences_disponibles)
  
  #essence_selectionnee <- readline(prompt = "Veuillez sélectionner une essence : ")
  
  # Filtrer les données pour l'essence sélectionnée
  #data <- subset(data, Essence == "Sapin pectiné")
  
essence_selectionnee <<- "Sapin pectiné"

data <- subset(data, Essence == essence_selectionnee)
  
  #if (nrow(data) == 0) {
    #stop("Aucune donnée disponible pour l'essence sélectionnée.")
  #}
  
  return(data)
}

```

`nettoyer_donnees` : Cette fonction nettoie les données en éliminant les valeurs manquantes (NA) pour les diamètres et les volumes. Elle convertit aussi les colonnes en format numérique pour faciliter les calculs ultérieurs.

```{r, warning=FALSE}

nettoyer_donnees <- function(data) {
  data <- data[!is.na(data$diam) & !is.na(data$V), ]
  
  # Convertir les colonnes en numériques
  data$diam <- as.numeric(data$diam)
  data$V <- as.numeric(data$V)
  
  return(data)
}

```

Une fois les données préparées, la relation entre le diamètre des arbres et leur volume est modélisée à l'aide d'un modèle polynomial.

`ajuster_modele_polynomial` : Cette fonction ajuste un modèle polynomial de degré 2 (quadratique) pour modéliser la relation entre le diamètre et le volume des arbres pour une essence donnée. Ce modèle est basé sur les données disponibles dans la base.

```{r, warning=FALSE}

# Fonction pour ajuster le modèle polynomial
ajuster_modele_polynomial <- function(data) {
  modele_poly <- lm(V ~ poly(diam, 2), data = data)
  return(modele_poly)
}

```

Les tarifs Shaeffer sont des tables qui fournissent des modèles standards pour estimer le volume d'un arbre en fonction de son diamètre. Deux types de tarifs sont utilisés : les tarifs "lents" et les tarifs "rapides", chacun offrant 20 modèles différents.

`lire_tarifs` : Cette fonction permet de lire les fichiers CSV contenant les tarifs Shaeffer "lents" et "rapides". Elle importe les données et les formate correctement pour pouvoir les utiliser dans les comparaisons.

```{r, warning=FALSE}

# Fonction pour lire les fichiers de tarifs
lire_tarifs <- function(filepath) {
  tarif <- read.csv(filepath, header = TRUE, sep = ';')
  tarif[] <- lapply(tarif, function(x) gsub(",", ".", x))  # Remplacer les virgules par des points
  tarif$Diametre <- as.numeric(tarif$Diametre)  # Convertir les colonnes en numériques
  tarif[, 2:ncol(tarif)] <- lapply(tarif[, 2:ncol(tarif)], as.numeric)
  return(tarif)
}

```

Une fois les tarifs importés, il est nécessaire de comparer le modèle polynomial ajusté avec les modèles des tarifs Shaeffer pour sélectionner celui qui correspond le mieux aux données réelles.

`compare_with_tarif` : Cette fonction compare le modèle polynomial avec chaque modèle de tarif Shaeffer. Elle calcule l'erreur quadratique moyenne (MSE) entre les volumes prédits par le modèle polynomial et ceux des tarifs pour un ensemble de diamètres. Le modèle de tarif qui donne la MSE la plus faible est sélectionné comme étant le plus adapté.

`calculate_mse` : Cette fonction calcule l'erreur moyenne quadratique (MSE)

```{r, warning=FALSE}

# Fonction pour comparer le modèle polynomial avec un tarif donné
compare_with_tarif <- function(tarif_data, tarif_type, data) {
  diameters <- tarif_data$Diametre
  mse_values <- c()
  
  for (i in 2:ncol(tarif_data)) {  # Les colonnes 2 à n sont les volumes
    volumes_tarif <- tarif_data[[i]]
    
    # Interpolation pour correspondre aux diamètres de l'étude
    volumes_interp <- approx(diameters, volumes_tarif, data$diam, rule = 2)$y
    
    # Vérifier si les volumes interpolés contiennent des NA
    if (all(is.na(volumes_interp))) {
      next  # Si tous les volumes interpolés sont NA, ignorer cette courbe
    }
    
    # Calcul de la MSE entre le modèle polynomial et le tarif
    mse <- calculate_mse(data$V, volumes_interp)
    mse_values <- c(mse_values, mse)
  }
  
  # Retourner la MSE la plus faible, l'index du tarif correspondant, et le type de tarif
  if (length(mse_values) == 0 || all(is.na(mse_values))) {
    return(list(min_mse = Inf, best_tarif = NA, type = tarif_type))
  }
  
  min_mse <- min(mse_values, na.rm = TRUE)
  best_tarif <- which.min(mse_values) + 1  # +1 à cause de la colonne 'Diametre'
  return(list(min_mse = min_mse, best_tarif = best_tarif, type = tarif_type))
}


# Fonction pour calculer l'erreur quadratique moyenne (MSE)
calculate_mse <- function(vol_predicted, vol_actual) {
  if (any(is.na(vol_predicted)) || any(is.na(vol_actual))) {
    return(NA)  # Retourner NA si des valeurs manquent
  }
  return(mean((vol_predicted - vol_actual)^2))
}

```

`comparer_tarifs` : Cette fonction compare les modèles "lents" et "rapides" pour déterminer lequel des deux types de tarifs est le plus précis pour l'essence d'arbre étudiée. Elle renvoie le meilleur modèle de tarif ainsi que le type (lent ou rapide).

```{r, warning=FALSE}

# Fonction pour comparer les tarifs lents et rapides
comparer_tarifs <- function(data, tarif_lent, tarif_rapide) {
  best_tarif_lent <- compare_with_tarif(tarif_lent, "lent", data)
  best_tarif_rapide <- compare_with_tarif(tarif_rapide, "rapide", data)
  
  # Comparer les MSE pour déterminer le meilleur tarif
  best_tarif <- best_tarif_lent
  if (!is.na(best_tarif_rapide$min_mse) && best_tarif_rapide$min_mse < best_tarif$min_mse) {
    best_tarif <- best_tarif_rapide
  }
  
  return(best_tarif)
}

```

Une fois le tarif approprié sélectionné, le calcul de l'accroissement volumique peut être effectué. Ce calcul se base sur les données de diamètre mesurées à deux dates distinctes (diamètre maximal et minimal) pour chaque arbre.

`calculer_accroissements_volumetriques` : Cette fonction calcule l'accroissement volumique annuel en utilisant le meilleur modèle de tarif Shaeffer. Elle commence par extraire les volumes correspondant aux diamètres maximaux et minimaux de chaque arbre à partir du tarif sélectionné. Ensuite, l'accroissement total est calculé en prenant la différence entre le volume maximal et minimal, puis cette différence est divisée par le nombre d'années entre les deux mesures pour obtenir l'accroissement volumique annuel.

```{r, warning=FALSE}

# Calcul des accroissements volumétriques
calculer_accroissements_volumetriques <- function(arbre_zone_etude_cor, best_tarif, tarif_lent, tarif_rapide) {
  # Extraire les valeurs de M pour un diamètre de 45
  M_lent_45 <- tarif_lent[tarif_lent$Diametre == 45, ]
  M_rapide_45 <- tarif_rapide[tarif_rapide$Diametre == 45, ]
  
  # Calculer le diamètre maximum et minimum
  arbre_zone_etude_cor$diam_max <- arbre_zone_etude_cor$circonference_max / pi
  arbre_zone_etude_cor$diam_min <- arbre_zone_etude_cor$circonference_min / pi
  arbre_zone_etude_cor$accroissement_volumique <- NA
  arbre_zone_etude_cor$V_max <- NA  # Initialise la colonne V_max avec des NA
  arbre_zone_etude_cor$V_max_ha <- NA  # Initialise la colonne V_max avec des NA
  
  # Boucle sur chaque arbre pour calculer l'accroissement volumétrique
  for (i in 1:nrow(arbre_zone_etude_cor)) {
    ligne <- arbre_zone_etude_cor[i, ]
    
    if (!is.na(ligne$veget_etat) && ligne$veget_etat != "Arbre vivant sur pied") {
      arbre_zone_etude_cor$accroissement_volumique[i] <- NA
      next
    }
    
    
    if (ligne$diam_max != ligne$diam_min) {
      difference_annees <- ligne$annee_max - ligne$annee_min
      
      if (best_tarif$type == "lent") {
        # Calcul avec tarif lent
        
        M <- M_lent_45[[best_tarif$best_tarif]]
        V_lent_max <- (M / 1400) * ((ligne$diam_max * 100 - 5) * (ligne$diam_max * 100 - 10))
        V_lent_min <- (M / 1400) * ((ligne$diam_min * 100 - 5) * (ligne$diam_min * 100 - 10))
        accroissement_total <- V_lent_max - V_lent_min
        
        arbre_zone_etude_cor$V_max[i] <- V_lent_max  # Remplace NA par la valeur calculée pour chaque ligne
        # Calculer V_max_ha (V_max * w) et ajouter la valeur dans la colonne V_max_ha
        arbre_zone_etude_cor$V_max_ha[i] <- V_lent_max * ligne$w  # Multiplie V_max par w pour chaque ligne
        
      } else {
        # Calcul avec tarif rapide
        M <- M_rapide_45[[best_tarif$best_tarif]]
        V_rapide_max <- (M / 1800) * ligne$diam_max * 100 * (ligne$diam_max * 100 - 5)
        V_rapide_min <- (M / 1800) * ligne$diam_min * 100 * (ligne$diam_min * 100 - 5)
        accroissement_total <- V_rapide_max - V_rapide_min
        
        arbre_zone_etude_cor$V_max[i] <- V_rapide_max  # Remplace NA par la valeur calculée pour chaque ligne
        arbre_zone_etude_cor$V_max_ha[i] <- V_rapide_max * ligne$w  # Multiplie V_max par w pour chaque ligne
        
        
      }
      
      # Calcul de l'accroissement volumique annuel
      arbre_zone_etude_cor$accroissement_volumique[i] <- accroissement_total / difference_annees
    } else {
      # Pas d'accroissement si annee_max == annee_min
      arbre_zone_etude_cor$accroissement_volumique[i] <- NA
    }
  }
  
  # Retourner les données mises à jour
  return(arbre_zone_etude_cor)
}



```

### Visualisation des résultats

Pour permettre une visualisation des résultats, une fonction permet d'afficher graphiquement les données réelles et les courbes des modèles.

`visualiser_resultats` : Cette fonction génère un graphique qui montre la relation entre le diamètre et le volume des arbres. Elle superpose la courbe du modèle polynomial ajusté aux données réelles ainsi que la courbe du tarif Shaeffer le plus adapté, afin de visualiser la précision du modèle sélectionné.

```{r, warning=FALSE}

# Fonction pour visualiser les résultats
visualiser_resultats <- function(data, modele_poly, best_tarif, tarif_lent, tarif_rapide) {
  # Plot des données
  plot(data$diam, data$V, 
       xlab = "Diamètre (cm)", 
       ylab = "Volume (m³)", 
       main = "Volume en fonction du diamètre", 
       pch = 16, col = "blue")
  
  # Ajout de la courbe polynomiale
  lines(sort(data$diam), 
        predict(modele_poly, newdata = data.frame(diam = sort(data$diam))), 
        col = "green", lwd = 2)
  
  # Ajouter la courbe du tarif Shaeffer choisi
  tarif_data <- if (best_tarif$type == "lent") tarif_lent else tarif_rapide
  volumes_tarif <- tarif_data[[best_tarif$best_tarif]]
  volumes_interp <- approx(tarif_data$Diametre, volumes_tarif, data$diam, rule = 2)$y
  
  lines(sort(data$diam), 
        volumes_interp[order(data$diam)], 
        col = "red", lwd = 2, lty = 2)
  
  # Afficher la légende
  legend("topleft", 
         legend = c("Données réelles", 
                    "Modèle polynomial", 
                    paste("Tarif Shaeffer -", best_tarif$best_tarif), 
                    paste("Essence :", essence_selectionnee)), 
         col = c("blue", "green", "red", "black"), 
         lty = c(NA, 1, 2, NA), 
         pch = c(16, NA, NA, NA),
         bty = "n")

  
  print(paste("Le meilleur tarif est :", best_tarif$best_tarif, 
              "de type", best_tarif$type, 
              "avec une MSE de", best_tarif$min_mse))
}

```

Le tout est exécuté par la fonction générale `get_accroissements_V()`, qui renvoie les volumes et taux d'accroissements par hectare.

```{r, warning=FALSE}
# Fonction principale : get_accroissements_V
get_accroissements_V <- function(buffer = 0) {
  # Étape 1 : Préparer les données
  get_import_zone()
  get_buffer_zone(buffer)
  get_read_map()
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  
  arbre_zone_etude_cor <<- selectionner_essence(arbre_zone_etude_cor)
  arbre_zone_etude_cor <<- nettoyer_donnees(arbre_zone_etude_cor)
  modele_poly <<- ajuster_modele_polynomial(arbre_zone_etude_cor)
  
  # Lire les tarifs
  tarif_lent <<- lire_tarifs("./tarif_shaeffer_lent.csv")
  tarif_rapide <<- lire_tarifs("./tarif_shaeffer_rapide.csv")
  
  # Comparer et sélectionner le meilleur tarif
  best_tarif <<- comparer_tarifs(arbre_zone_etude_cor, tarif_lent, tarif_rapide)
  
  # Étape 2 : Calculer les accroissements volumétriques
  arbre_zone_etude_cor <<- calculer_accroissements_volumetriques(arbre_zone_etude_cor, best_tarif, tarif_lent, tarif_rapide)
  
  get_calc_V_ha()
  get_taux_acc_V()
  get_read_acc_V()
  
  # Afficher le résultat
  View(arbre_zone_etude_cor)
  return(arbre_zone_etude_cor)
}
```

#### Exemple de la fonction get_acccroissements_V sur le parc naturel régional de Chartreuse

```{r, warning=FALSE}
get_accroissements_V()
print(volume_placette)
print(table_recap_final_V)
```

## Calcul de l'accroissement en diamètre D(cm/an)

La fonction get_acc_D calcule les moyennes d'accroissement en diamètre des arbres par essence, catégorie de diamètre, et placette. Elle commence par filtrer les données pour exclure les valeurs infinies et petites, puis regroupe les informations par placette, essence et catégorie de diamètre. Pour chaque groupe, la moyenne d'accroissement en diamètre (acc_D_cm) est calculée. Les moyennes obtenues par placette sont ensuite regroupées par essence et catégorie de diamètre afin d'obtenir des moyennes globales sur l'ensemble des placettes. Les valeurs sont arrondies pour simplifier la présentation, et pivot_wider est utilisé pour organiser les résultats avec des colonnes correspondant aux différentes catégories de diamètre.

Par ailleurs, une moyenne d'accroissement sans distinction de catégorie de diamètre est calculée, en regroupant uniquement par essence et placette. Cette moyenne globale est fusionnée avec les moyennes par catégorie de diamètre pour produire un tableau final contenant les deux types de résultats.

Le tableau final est affiché dans une vue et retourné sous la forme de table_recap_final_D pour un usage ultérieur.

```{r, warning=FALSE}
# Fonction intégral calcul de l'accroissement en D/cm/an
get_acc_D <- function(buffer = 0){
  get_import_zone()
  get_buffer_zone(buffer)
  get_read_map()
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  get_calc_D()
  get_read_acc_D()
  View(table_recap_final_D)
  
  return(plot_zone)
}
```

```{r, echo = FALSE, results='hide', message=FALSE, warning=FALSE}
get_read_acc_D <- function(){
  
  # Calculer les moyennes d'accroissement par essence, catégorie de diamètre et placette
  table_recap_placette <- arbre_zone_etude_cor %>%
    filter(is.finite(acc_D_cm)) %>%  # Exclure les valeurs infinies et petites
    group_by(IDP, Essence, cat_diam) %>%  # Groupement par Placette, Essence et catégorie de diamètre
    summarise(
      moyenne_accroissement = mean(acc_D_cm, na.rm = TRUE),  # Moyenne d'accroissement pour chaque placette
      .groups = 'drop'
    )
  
  # Calculer la moyenne sur toutes les placettes par essence et catégorie de diamètre
  table_recap_global <- table_recap_placette %>%
    group_by(Essence, cat_diam) %>%  # Groupement par Essence et catégorie de diamètre seulement
    summarise(
      moyenne_accroissement_placettes = mean(moyenne_accroissement, na.rm = TRUE),  # Moyenne globale sur toutes les placettes
      .groups = 'drop'
    ) %>%
    mutate(moyenne_accroissement_placettes = round(moyenne_accroissement_placettes, 3)) %>%  # Arrondir à 0.001 près
    pivot_wider(
      names_from = cat_diam,  # Colonnes pour chaque catégorie de diamètre
      values_from = moyenne_accroissement_placettes,
      values_fill = list(moyenne_accroissement_placettes = NA)  # Remplir les valeurs manquantes avec NA
    ) %>%
    arrange(Essence)  # Trier par essence
  
  # Calculer la moyenne globale par essence sans distinction de catégorie de diamètre
  table_recap_global_sans_diam <- arbre_zone_etude_cor %>%
    filter(is.finite(acc_D_cm)) %>%
    group_by(IDP, Essence) %>%  # Groupement par Placette et Essence uniquement
    summarise(
      moyenne_accroissement_sans_diam = mean(acc_D_cm, na.rm = TRUE),  # Moyenne d'accroissement par placette sans cat_diam
      .groups = 'drop'
    ) %>%
    group_by(Essence) %>%  # Groupement par essence pour faire la moyenne globale de toutes les placettes
    summarise(
      moy_acc_D_cm_an = mean(moyenne_accroissement_sans_diam, na.rm = TRUE),  # Moyenne globale sur toutes les placettes
      #nombre_arbres_mesures = sum(!is.na(acc_g_ha) & acc_g_ha != 0 & is.finite(acc_g_ha)),
      .groups = 'drop'
    ) %>%
    mutate(moy_acc_D_cm_an = round(moy_acc_D_cm_an, 3))  # Arrondir à 0.001 près
  
  # Fusionner les résultats avec ou sans catégorie de diamètre
  table_recap_final_D <<- table_recap_global %>%
    left_join(table_recap_global_sans_diam, by = "Essence")  # Ajouter la moyenne sans catégorie de diamètre
  
  View(table_recap_final_D)
  
  return(table_recap_final_D)
  
}

# Fonction calcul accroissement en D/cm/an----
get_calc_D <- function(){
  arbre_zone_etude_cor <<- arbre_zone_etude_cor %>%
    group_by(num_unique) %>%
    # Calculer l'accroissement annuel en V
    mutate(
      HTOT = as.numeric(HTOT),
      acc_D_cm = if_else(
        circonference_max != circonference_min,
        
        (((circonference_max / pi) - (circonference_min / pi)) / (annee_max - annee_min)) * 100,
        
        NA_real_  # Sinon NA
      ))
}

```

```{r,warning=FALSE}
get_acc_D()
print(table_recap_final_D)
```

## Complément de fonction pour les données IFN : Sylvoécorégion et région forestières

En complément des fonctions d'accroissement de la surface terrière et du volume basé sur une géométrie spécifiée par l'utilisateur, nous avons développé deux autres fonctions permettant de calculer les accroissements selon les sylvoécorégions et les régions forestières. Ces fonctions exécutent les mêmes opérations que les précédentes, avec pour seule différence la variable utilisée pour la récupération de la géométrie, qui correspond soit à la sylvoécorégion, soit à la région forestière, en fonction du choix de l'utilisateur.

Ces fonctions permettent ainsi d'obtenir des données d'accroissement en prenant en compte les spécificités des différentes unités de gestion forestière, offrant ainsi une analyse plus adaptée aux contextes sylvicoles plus larges.

```{r title(Fonction sylvoecoregion et region forestière), warning=FALSE}
# Obtenir les placettes et arbre mesurer d'une sylvoecoregion ----
get_sylvo_eco <- function(sylvoecoregion) {
  # Charger les données ser
  data("ser")           # Charger l'objet 'ser'
  
  # Filtrer le polygone correspondant au nom donné
  shp_etude <<- ser %>% filter(ser$NomSER == sylvoecoregion)
  
  get_buffer_zone()
  get_read_map()
  
  return(plot_zone)
}

# Obtenir les placettes et arbre mesurer d'une région forestière ----
get_reg_foret <- function(reg_foret) {
  # Charger les données ser et des placettes
  data("rfn")           # Charger l'objet 'rfn'
  
  # Filtrer le polygone correspondant au nom donné
  shp_etude <<- rfn %>% filter(rfn$REGIONN == reg_foret)
  get_buffer_zone()
  get_read_map()
  
  return(plot_zone)
}

# Obtenir l'accroissement en G/m²/ha/an d'une sylvoecoregion----
get_acc_G_sylvo_eco <- function(sylvoecoregion){
  get_sylvo_eco(sylvoecoregion)
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  get_calc_G()
  get_taux_acc_g()
  get_read_acc_G()
  
  return(plot_zone)
  
}

# Obtenir l'accroissement en G/m²/ha/an d'une Région forestière----
get_acc_G_reg_foret <- function(reg_foret){
  get_reg_foret(reg_foret)
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  get_calc_G()
  get_taux_acc_g()
  get_read_acc_G()
  
  return(plot_zone)
  
}

# Obtenir l'accroissement en V/m3/ha/an d'une sylvoecoregion----
get_acc_V_sylvo_eco <- function(sylvoecoregion){
  get_sylvo_eco(sylvoecoregion)
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  
  arbre_zone_etude_cor <<- selectionner_essence(arbre_zone_etude_cor)
  arbre_zone_etude_cor <<- nettoyer_donnees(arbre_zone_etude_cor)
  modele_poly <<- ajuster_modele_polynomial(arbre_zone_etude_cor)
  
  # Lire les tarifs
  tarif_lent <<- lire_tarifs("./tarif_shaeffer_lent.csv")
  tarif_rapide <<- lire_tarifs("./tarif_shaeffer_rapide.csv")
  
  # Comparer et sélectionner le meilleur tarif
  best_tarif <<- comparer_tarifs(arbre_zone_etude_cor, tarif_lent, tarif_rapide)
  
  # Étape 2 : Calculer les accroissements volumétriques
  arbre_zone_etude_cor <<- calculer_accroissements_volumetriques(arbre_zone_etude_cor, best_tarif, tarif_lent, tarif_rapide)
  
  get_calc_V_ha()
  get_taux_acc_V()
  get_read_acc_V()
  
  # Afficher le résultat
  View(arbre_zone_etude_cor)
  
  return(plot_zone)
  
}

# Obtenir l'accroissement en V/m3/ha/an d'une région forestière----
get_acc_V_reg_foret <- function(reg_foret){
  get_reg_foret(reg_foret)
  get_arrange_data()
  get_species()
  get_data_dendro()
  get_veget()
  
  arbre_zone_etude_cor <<- selectionner_essence(arbre_zone_etude_cor)
  arbre_zone_etude_cor <<- nettoyer_donnees(arbre_zone_etude_cor)
  modele_poly <<- ajuster_modele_polynomial(arbre_zone_etude_cor)
  
  # Lire les tarifs
  tarif_lent <<- lire_tarifs("./tarif_shaeffer_lent.csv")
  tarif_rapide <<- lire_tarifs("./tarif_shaeffer_rapide.csv")
  
  # Comparer et sélectionner le meilleur tarif
  best_tarif <<- comparer_tarifs(arbre_zone_etude_cor, tarif_lent, tarif_rapide)
  
  # Étape 2 : Calculer les accroissements volumétriques
  arbre_zone_etude_cor <<- calculer_accroissements_volumetriques(arbre_zone_etude_cor, best_tarif, tarif_lent, tarif_rapide)
  
  get_calc_V_ha()
  get_taux_acc_V()
  get_read_acc_V()
  
  # Afficher le résultat
  View(arbre_zone_etude_cor)
  
  return(plot_zone)
  
}

```

### Complément de fonction : Obtention des tarifs de cubage Schaeffer par essence

L'objectif de cette fonction est de récupérer, pour la zone d'étude, l'ensemble des tarifs de cubage Schaeffer pour toutes les essences répertoriées par les données de l'IFN. L'utilisateur peut également définir une limite minimale de données pour la création des tarifs. Cette variable est essentielle car, si les données disponibles sont insuffisantes ou mal réparties dans la structure des bois, les résultats obtenus peuvent être erronés. Par défaut, la fonction est configurée pour ne traiter que les données correspondant à un minimum de 50 arbres pour le calcul des tarifs.

```{r title(Fonction de récupération des tarifs par essence), warning=FALSE}
# Fonction principale pour calculer les tarifs pour chaque essence
calculer_tarifs_pour_chaque_essence <- function(arbre_zone_etude_cor, tarif_lent, tarif_rapide,nbr_arbre_min=50) {
  
  # Récupérer la liste des essences uniques dans la table
  essences_uniques <- unique(arbre_zone_etude_cor$Essence)
  
  # Créer un data frame pour stocker les résultats récapitulatifs
  recap_table <- data.frame(Essence = character(), Best_Tarif = numeric(), Tarif_Type = character(), Message = character(), stringsAsFactors = FALSE)
  
  # Boucle sur chaque essence
  for (essence in essences_uniques) {
    
    # Filtrer les données pour cette essence
    data_essence <- arbre_zone_etude_cor %>%
      filter(Essence == essence)
    
    # Nettoyer les données
    data_nettoyee <- nettoyer_donnees(data_essence)
    
    # Vérifier le nombre d'arbres mesurés pour cette essence
    nombre_arbres <- nrow(data_nettoyee)
    
    if (nombre_arbres < nbr_arbre_min) {
      # Si moins de 50 arbres, ajouter une ligne indiquant pas assez de données
      recap_table <- rbind(recap_table, data.frame(
        Essence = essence,
        Best_Tarif = NA,
        Tarif_Type = NA,
        Message = "Pas assez de données",
        stringsAsFactors = FALSE
      ))
      next  # Passer à l'essence suivante
    }
    
    # Ajuster le modèle polynomial
    modele_poly <- ajuster_modele_polynomial(data_nettoyee)
    
    # Comparer avec les tarifs lents et rapides
    best_tarif <- comparer_tarifs(data_nettoyee, tarif_lent, tarif_rapide)
    
    # Ajouter les résultats au tableau récapitulatif
    recap_table <- rbind(recap_table, data.frame(
      Essence = essence,
      Best_Tarif = best_tarif$best_tarif,
      Tarif_Type = best_tarif$type,
      #nombre_arbre_mesure = nombre_arbres,
      Message = "Données suffisantes",
      stringsAsFactors = FALSE
    ))
    
    # Visualiser les résultats (optionnel)
    visualiser_resultats(data_nettoyee, modele_poly, best_tarif, tarif_lent, tarif_rapide)
  }
  
  return(recap_table)  # Retourner le tableau récapitulatif à la fin
}
```

Pour pouvoir executer correctement cette fonction il est nécessaire de charger les tables des tarifs lent et rapide de Schaeffer :

```{r title(Chargement des tarifs), warning=FALSE}
tarif_lent <- lire_tarifs("./tarif_shaeffer_lent.csv")
tarif_rapide <- lire_tarifs("./tarif_shaeffer_rapide.csv")

```

A titre d'exemple sur le parc naturel régional de chartreuse, on peut obtenir les tarifs suivant, avec `nombre_arbre_min` = 200 :

```{r title(Execution fonction tarif), warning=FALSE}
# nombre_arbre_min, valeur par défaut = 50
resultats_tarif_par_essence <<- calculer_tarifs_pour_chaque_essence(arbre_zone_etude_cor, tarif_lent, tarif_rapide,200)

# Affichage du tableau récapitulatif
View(resultats_tarif_par_essence)
print(resultats_tarif_par_essence)
```

# Discussion

Notre projet présente certaines limites qu'il convient de souligner. Tout d'abord, la faible densité des placettes de l'Inventaire Forestier National (IFN) peut entraîner un manque de représentativité, notamment sur de petites surfaces, telles un hectare. Ensuite, les données de l'IFN posent parfois des difficultés, notamment parce que l'organisme modifie régulièrement son protocole de récupération des résultats, ce qui constitue une contrainte supplémentaire.

De plus, le script actuel se heurte à une contrainte technique : le fichier contenant les données des arbres, téléchargé dès le début, est particulièrement lourd. Il serait préférable que chaque fonction récupère de manière ciblée, en fonction de la zone géographique, les données de l'IFN.

Enfin, notre modèle génère des résultats pour toutes les essences d'arbres, même celles qui sont peu représentées et reposent sur un nombre insuffisant de points d'observation, ce qui nécessite une vigilance de la part de l'utilisateur lors de l'interprétation des conclusions.

En termes de perspectives, il serait intéressant de travailler sur la mortalité des arbres, en identifiant les zones où les essences sont particulièrement affectées. De plus, un développement futur pourrait inclure un code fournissant des conseils de gestion forestière, basés sur des données spécifiques à la forêt concernée, telles que le volume de bois ou la surface terrière.
